diff --git a/Makefile b/Makefile
index b971308..8dcd337 100644
--- a/Makefile
+++ b/Makefile
@@ -36,6 +36,7 @@ OBJS = \
   $K/kernelvec.o \
   $K/plic.o \
   $K/virtio_disk.o \
+  
 
 ifeq ($(LAB),pgtbl)
 OBJS += $K/vmcopyin.o
@@ -157,6 +158,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep \
+	$U/_pingpong \
+	$U/_find \
 
 
 ifeq ($(LAB),syscall)
@@ -242,15 +246,8 @@ qemu-gdb: $K/kernel .gdbinit fs.img
 	@echo "*** Now run 'gdb' in another window." 1>&2
 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
 
-GDBARGS = 
-GDBARGS += -ex 'set architecture riscv:rv64'
-GDBARGS += -ex 'target remote 127.0.0.1:$(GDBPORT)'
-GDBARGS += -ex 'symbol-file kernel/kernel'
-GDBARGS += -ex 'set riscv use-compressed-breakpoints yes'
-
-
 gdb: 
-	$(GDB) $(GDBARGS)
+	$(GDB)
 
 ##
 ##  FOR testing lab grading script
diff --git a/clang-format.py b/clang-format.py
index f1bf537..1d2afed 100644
--- a/clang-format.py
+++ b/clang-format.py
@@ -10,4 +10,4 @@ for root, dirs, files in os.walk("kernel"):
 for root, dirs, files in os.walk("user"):
     for file in files:
         if file.endswith(c_extensions):
-            os.system("clang-format -i -style=file " + root + "/" + file)
\ No newline at end of file
+            os.system("clang-format -i -style=file " + root + "/" + file)
diff --git a/commands.gdb b/commands.gdb
new file mode 100644
index 0000000..066f3ed
--- /dev/null
+++ b/commands.gdb
@@ -0,0 +1,42 @@
+si 10
+si
+si
+si       
+b start.c:58
+c
+c
+c
+si     
+b main.c:42
+c
+c
+c
+s
+n
+n
+n
+n
+n
+s
+n
+n
+s
+n
+n     
+b proc.c:433
+c
+c
+c      
+p cpus[$tp]->proc->name    
+b trap.c:81       
+c
+c
+c
+c
+c
+c
+c
+c
+c
+p cpus[$tp]->proc->name       
+n
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..1f84747
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,82 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+// char *fmtname(char *path) {
+//   static char buf[DIRSIZ + 1];
+//   char *p;
+
+//   // Find first character after last slash.
+//   for (p = path + strlen(path); p >= path && *p != '/'; p--);
+//   p++;
+
+//   // Return blank-padded name.
+//   if (strlen(p) >= DIRSIZ) return p;
+//   memmove(buf, p, strlen(p));
+//   //  memset(buf + strlen(p), ' ', DIRSIZ - strlen(p));
+//   char *s = buf + strlen(p);
+//   *s = '\0';
+//   return buf;
+// }
+
+void printOut(const char *path, const char *name) { printf("%s\n", path); }
+
+void find(const char *path, const char *name) {
+  char buf[512], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+
+  if ((fd = open(path, 0)) < 0) {
+    fprintf(2, "find: cannot open %s\n", path);
+    return;
+  }
+
+  if (fstat(fd, &st) < 0) {
+    fprintf(2, "find：cannot stat %s\n", path);
+    close(fd);
+    return;
+  }
+
+  switch (st.type) {
+    case T_DIR:
+      if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
+        printf("find: path too long\n");
+        break;
+      }
+      strcpy(buf, path);
+      p = buf + strlen(buf);
+      *p++ = '/';
+      int n;
+      while ((n = read(fd, &de, sizeof(de))) == sizeof(de)) {
+        // printf("%d,%d,%d\n",de.inum,strlen(de.name),n);
+        if (strlen(de.name) == 0) break;
+        if (de.inum == 0 || strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0) continue;
+
+        memmove(p, de.name, DIRSIZ);
+        p[DIRSIZ] = 0;
+        if (stat(buf, &st) < 0) {
+          printf("find: cannot stat %s\n", buf);
+          continue;
+        }
+
+        if (strcmp(de.name, name) == 0) {
+          printOut(buf, name);
+        }
+        int new_fd = open(buf, 0);  // 以只读方式打开新目录
+
+        find(buf, name);  // 递归查找
+        close(new_fd);    // 关闭目录
+      }
+      break;
+  }
+  close(fd);
+}
+
+int main(int argc, char *argv[]) {
+  if (argc == 3) {
+    find(argv[1], argv[2]);
+  } else
+    fprintf(2, "wrong format! Enter the correct format like find <path> <name>");
+}
\ No newline at end of file
diff --git a/user/ls.c b/user/ls.c
index dca754a..b241e5d 100644
--- a/user/ls.c
+++ b/user/ls.c
@@ -50,7 +50,8 @@ void ls(char *path) {
       p = buf + strlen(buf);
       *p++ = '/';
       while (read(fd, &de, sizeof(de)) == sizeof(de)) {
-        if (de.inum == 0) continue;
+        if (de.inum == 0) 
+        continue;
         memmove(p, de.name, DIRSIZ);
         p[DIRSIZ] = 0;
         if (stat(buf, &st) < 0) {
@@ -71,6 +72,7 @@ int main(int argc, char *argv[]) {
     ls(".");
     exit(0);
   }
-  for (i = 1; i < argc; i++) ls(argv[i]);
+  for (i = 1; i < argc; i++) 
+  ls(argv[i]);
   exit(0);
 }
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..c883743
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,33 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main(int argc, char *argv[]) {
+  int c2f[2], f2c[2];
+  pipe(c2f);  // child -> parent
+  pipe(f2c);  // parent ->child
+  int fpid = getpid(), cpid;
+  char ping[100];
+  char pong[100];
+
+  if ((cpid = fork()) == 0) {
+    close(f2c[1]);
+    read(f2c[0], ping, sizeof(ping) - 1);
+    printf("%d: received %s from pid %d\n", getpid(), ping, fpid);
+    close(f2c[0]);
+
+    close(c2f[0]);
+    write(c2f[1], "pong", 4);
+    close(c2f[1]);
+  } else {
+    close(f2c[0]);
+    write(f2c[1], "ping", 4);
+    close(f2c[1]);
+
+    close(c2f[1]);
+    read(c2f[0], pong, sizeof(pong) - 1);
+    printf("%d: received %s from pid %d\n", fpid, pong, cpid);
+    close(c2f[1]);
+  }
+
+  exit(0);
+}
\ No newline at end of file
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..3bd1b64
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,14 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main(int argc, char *argv[]) {
+  if (argc != 2) {
+    printf("Sleep needs one argument!\n");  // 检查参数数量是否正确
+    exit(-1);
+  }
+  
+  int ticks = atoi(argv[1]);  // 将字符串参数转为整数
+  sleep(ticks);               // 使用系统调用sleep
+  printf("(nothing happens for a little while) \n");
+  exit(0);  // 确保进程退出
+}
\ No newline at end of file
